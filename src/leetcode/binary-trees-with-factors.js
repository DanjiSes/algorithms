/**
 * @param {number[]} arr
 * @return {number}
 */
var numFactoredBinaryTrees = function(arr) {
    const mod = 10 ** 9 + 7;
    
    // сортирую все элемены по возрастанию
    arr.sort((a, b) => a - b);
    
    // хешмап в которм храню сколько деревьев я могу построить из каждого элемента
    const dp = {};
    
    for (const num of arr) {
        // проставляю на каждый элемент по еденице так как каждый элемент уже может служить древом
        dp[num] = 1;
    }
    
    // прохожусь по каждому элементу начиная с второго
    for (let i = 1; i < arr.length; i++) {
        const root = arr[i] // - текущий элемент

        // прохожусь еще раз по каждому элементу от начала до текущего элемента i
        for (let j = 0; j < i; j++) {
            const a = arr[j] // - первый множитель
            
            // если элемент делится без остатка на первый множетель
            if (root % a === 0) {
                const b = root / a; // - второй множетель

                // если у нас есть элемент равный второму множетелью
                if (dp[b]) {
                    // текущему элементу добавляю кол-во вариантов посторения древа равноее кол-ву вариантов построить из первого множетеля умноженное на кол-во вариантов построить из второго множителя
                    dp[root] = (dp[root] + dp[a] * dp[b]) % mod;
                }
            }
        }
    }
    
    let ans = 0;
    Object.values(dp).forEach(v => ans += v);
    return ans % mod;
};

module.exports = numFactoredBinaryTrees;
